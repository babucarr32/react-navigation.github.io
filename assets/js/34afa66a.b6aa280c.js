"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([["9615"],{16420:function(e,t,n){n.r(t),n.d(t,{metadata:()=>i,contentTitle:()=>c,default:()=>h,assets:()=>r,toc:()=>l,frontMatter:()=>s});var i=JSON.parse('{"id":"navigation-lifecycle","title":"Navigation lifecycle","description":"In the previous section, we worked with a stack navigator that has two screens (Home and Details) and learned how to use this.props.navigation.navigate(\'RouteName\') to navigate between the routes.","source":"@site/versioned_docs/version-3.x/navigation-lifecycle.md","sourceDirName":".","slug":"/navigation-lifecycle","permalink":"/docs/3.x/navigation-lifecycle","draft":false,"unlisted":false,"editUrl":"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-3.x/navigation-lifecycle.md","tags":[],"version":"3.x","frontMatter":{"id":"navigation-lifecycle","title":"Navigation lifecycle","sidebar_label":"Navigation lifecycle"},"sidebar":"version-3.x-docs","previous":{"title":"Moving between screens","permalink":"/docs/3.x/navigating"},"next":{"title":"Passing parameters to routes","permalink":"/docs/3.x/params"}}'),a=n("85893"),o=n("50065");let s={id:"navigation-lifecycle",title:"Navigation lifecycle",sidebar_label:"Navigation lifecycle"},c=void 0,r={},l=[{value:"Example scenario",id:"example-scenario",level:2},{value:"React Navigation lifecycle events",id:"react-navigation-lifecycle-events",level:2},{value:"Summary",id:"summary",level:2}];function d(e){let t={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["In the previous section, we worked with a stack navigator that has two screens (",(0,a.jsx)(t.code,{children:"Home"})," and ",(0,a.jsx)(t.code,{children:"Details"}),") and learned how to use ",(0,a.jsx)(t.code,{children:"this.props.navigation.navigate('RouteName')"})," to navigate between the routes."]}),"\n",(0,a.jsxs)(t.p,{children:["An important question in this context is: what happens with ",(0,a.jsx)(t.code,{children:"Home"})," when we navigate away from it, or when we come back to it? How does a route find out that a user is leaving it or coming back to it?"]}),"\n",(0,a.jsxs)(t.p,{children:["Coming to react-navigation from the web, you may assume that when user navigates from route A to route B, A will unmount (its ",(0,a.jsx)(t.code,{children:"componentWillUnmount"})," is called) and A will mount again when user comes back to it. While these React lifecycle methods are still valid and are used in react-navigation, their usage differs from the web. This is driven by more complex needs of mobile navigation."]}),"\n",(0,a.jsx)(t.h2,{id:"example-scenario",children:"Example scenario"}),"\n",(0,a.jsxs)(t.p,{children:["Consider a stack navigator with screens A and B. After navigating to A, its ",(0,a.jsx)(t.code,{children:"componentDidMount"})," is called. When pushing B, its ",(0,a.jsx)(t.code,{children:"componentDidMount"})," is also called, but A remains mounted on the stack and its ",(0,a.jsx)(t.code,{children:"componentWillUnmount"})," is therefore not called."]}),"\n",(0,a.jsxs)(t.p,{children:["When going back from B to A, ",(0,a.jsx)(t.code,{children:"componentWillUnmount"})," of B is called, but ",(0,a.jsx)(t.code,{children:"componentDidMount"})," of A is not because A remained mounted the whole time."]}),"\n",(0,a.jsx)(t.p,{children:"Similar results can be observed (in combination) with other navigators as well. Consider a tab navigator with two tabs, where each tab is a stack navigator:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:"const HomeStack = createStackNavigator({\n  Home: HomeScreen,\n  Details: DetailsScreen,\n});\n\nconst SettingsStack = createStackNavigator({\n  Settings: SettingsScreen,\n  Profile: ProfileScreen,\n});\n\nconst TabNavigator = createBottomTabNavigator({\n  Home: HomeStack,\n  Settings: SettingsStack,\n});\n"})}),"\n",(0,a.jsxs)(t.p,{children:["We start on the ",(0,a.jsx)(t.code,{children:"HomeScreen"})," and navigate to ",(0,a.jsx)(t.code,{children:"DetailsScreen"}),". Then we use the tab bar to switch to the ",(0,a.jsx)(t.code,{children:"SettingsScreen"})," and navigate to ",(0,a.jsx)(t.code,{children:"ProfileScreen"}),". After this sequence of operations is done, all 4 of the screens are mounted! If you use the tab bar to switch back to the ",(0,a.jsx)(t.code,{children:"HomeStack"}),", you'll notice you'll be presented with the ",(0,a.jsx)(t.code,{children:"DetailsScreen"})," - the navigation state of the ",(0,a.jsx)(t.code,{children:"HomeStack"})," has been preserved!"]}),"\n",(0,a.jsx)(t.h2,{id:"react-navigation-lifecycle-events",children:"React Navigation lifecycle events"}),"\n",(0,a.jsx)(t.p,{children:'Now that we understand how React lifecycle methods work in React Navigation, let\'s answer the question we asked at the beginning: "How do we find out that a user is leaving it or coming back to it?"'}),"\n",(0,a.jsxs)(t.p,{children:["React Navigation emits events to screen components that subscribe to them. There are four different events that you can subscribe to: ",(0,a.jsx)(t.code,{children:"willFocus"}),", ",(0,a.jsx)(t.code,{children:"willBlur"}),", ",(0,a.jsx)(t.code,{children:"didFocus"})," and ",(0,a.jsx)(t.code,{children:"didBlur"}),". Read more about them in the ",(0,a.jsx)(t.a,{href:"/docs/3.x/navigation-prop#addlistener---subscribe-to-updates-to-navigation-lifecycle",children:"API reference"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["Many of your use cases may be covered with the ",(0,a.jsxs)(t.a,{href:"/docs/3.x/with-navigation-focus",children:[(0,a.jsx)(t.code,{children:"withNavigationFocus"})," HOC"]})," or the ",(0,a.jsxs)(t.a,{href:"/docs/3.x/navigation-events",children:[(0,a.jsx)(t.code,{children:"<NavigationEvents />"})," component"]})," which are a little more straightforward to use."]}),"\n",(0,a.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["while React's lifecycle methods are still valid, React Navigation adds more lifecycle events that you can subscribe to through the ",(0,a.jsx)(t.code,{children:"navigation"})," prop."]}),"\n",(0,a.jsxs)(t.li,{children:["you may also use the ",(0,a.jsx)(t.code,{children:"withNavigationFocus"})," HOC or ",(0,a.jsx)(t.code,{children:"<NavigationEvents />"})," component to react to lifecycle changes"]}),"\n"]})]})}function h(e={}){let{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},50065:function(e,t,n){n.d(t,{Z:function(){return c},a:function(){return s}});var i=n(67294);let a={},o=i.createContext(a);function s(e){let t=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);